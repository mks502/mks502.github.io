---
layout: post
title: ğŸ“– [ë°±ì¤€ì•Œê³ ë¦¬ì¦˜ í’€ì´] Q.1261 ì•Œê³ ìŠ¤íŒŸ ë¬¸ì œ í’€ì´ - java
category : Algorithm
tags: [Algorithm,boj,shortest path, dijkstra]
---
# ğŸ“– ë¬¸ì œ
<https://www.acmicpc.net/problem/1261>

ì•Œê³ ìŠ¤íŒŸ ìš´ì˜ì§„ì´ ëª¨ë‘ ë¯¸ë¡œì— ê°‡í˜”ë‹¤. ë¯¸ë¡œëŠ” N*M í¬ê¸°ì´ë©°, ì´ 1*1í¬ê¸°ì˜ ë°©ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤. ë¯¸ë¡œëŠ” ë¹ˆ ë°© ë˜ëŠ” ë²½ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆê³ , ë¹ˆ ë°©ì€ ììœ ë¡­ê²Œ ë‹¤ë‹ ìˆ˜ ìˆì§€ë§Œ, ë²½ì€ ë¶€ìˆ˜ì§€ ì•Šìœ¼ë©´ ì´ë™í•  ìˆ˜ ì—†ë‹¤.

ì•Œê³ ìŠ¤íŒŸ ìš´ì˜ì§„ì€ ì—¬ëŸ¬ëª…ì´ì§€ë§Œ, í•­ìƒ ëª¨ë‘ ê°™ì€ ë°©ì— ìˆì–´ì•¼ í•œë‹¤. ì¦‰, ì—¬ëŸ¬ ëª…ì´ ë‹¤ë¥¸ ë°©ì— ìˆì„ ìˆ˜ëŠ” ì—†ë‹¤. ì–´ë–¤ ë°©ì—ì„œ ì´ë™í•  ìˆ˜ ìˆëŠ” ë°©ì€ ìƒí•˜ì¢Œìš°ë¡œ ì¸ì ‘í•œ ë¹ˆ ë°©ì´ë‹¤. ì¦‰, í˜„ì¬ ìš´ì˜ì§„ì´ (x, y)ì— ìˆì„ ë•Œ, ì´ë™í•  ìˆ˜ ìˆëŠ” ë°©ì€ (x+1, y), (x, y+1), (x-1, y), (x, y-1) ì´ë‹¤. ë‹¨, ë¯¸ë¡œì˜ ë°–ìœ¼ë¡œ ì´ë™ í•  ìˆ˜ëŠ” ì—†ë‹¤.

ë²½ì€ í‰ì†Œì—ëŠ” ì´ë™í•  ìˆ˜ ì—†ì§€ë§Œ, ì•Œê³ ìŠ¤íŒŸì˜ ë¬´ê¸° AOJë¥¼ ì´ìš©í•´ ë²½ì„ ë¶€ìˆ˜ì–´ ë²„ë¦´ ìˆ˜ ìˆë‹¤. ë²½ì„ ë¶€ìˆ˜ë©´, ë¹ˆ ë°©ê³¼ ë™ì¼í•œ ë°©ìœ¼ë¡œ ë³€í•œë‹¤.

ë§Œì•½ ì´ ë¬¸ì œê°€ ì•Œê³ ìŠ¤íŒŸì— ìˆë‹¤ë©´, ìš´ì˜ì§„ë“¤ì€ ê¶ê·¹ì˜ ë¬´ê¸° sudoë¥¼ ì´ìš©í•´ ë²½ì„ í•œ ë²ˆì— ë‹¤ ì—†ì• ë²„ë¦´ ìˆ˜ ìˆì§€ë§Œ, ì•ˆíƒ€ê¹ê²Œë„ ì´ ë¬¸ì œëŠ” Baekjoon Online Judgeì— ìˆ˜ë¡ë˜ì–´ ìˆê¸° ë•Œë¬¸ì—, sudoë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

í˜„ì¬ (1, 1)ì— ìˆëŠ” ì•Œê³ ìŠ¤íŒŸ ìš´ì˜ì§„ì´ (N, M)ìœ¼ë¡œ ì´ë™í•˜ë ¤ë©´ ë²½ì„ ìµœì†Œ ëª‡ ê°œ ë¶€ìˆ˜ì–´ì•¼ í•˜ëŠ”ì§€ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

# ğŸ” ì ‘ê·¼ë²•

BOJ Q.1261 ì•Œê³ ìŠ¤íŒŸ ë¬¸ì œì…ë‹ˆë‹¤. N*M í¬ê¸°ì˜ ë¯¸ë¡œê°€ ì£¼ì–´ì§€ê³  ë¯¸ë¡œëŠ” ë¹ˆ ë°© ë˜ëŠ” ë²½ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.

ë¹ˆ ë°©ì€ ê·¸ëƒ¥ ì§€ë‚˜ë‹¤ë‹ ìˆ˜ ìˆê³  ë²½ì€ ë¶€ìˆ˜ê³  ì´ë™ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì´ë™ì€ ì¸ì ‘í•œ ë™ì„œë‚¨ë¶ìœ¼ë¡œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.

1,1 ì§€ì ì—ì„œ ì¶œë°œí•œë‹¤ê³  í•  ë•Œ N,Mê¹Œì§€ ì´ë™ì„ í•˜ë ¤ê³  í•˜ëŠ”ë° ì´ë•Œ ë²½ì„ ìµœì†Œ ëª‡ ê°œë¥¼ ë¶€ìˆ´ì•¼í•˜ëŠ”ì§€ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

ë¬¸ì œë¥¼ ë³´ë©´ N*M í¬ê¸°ì˜ ë¯¸ë¡œê°€ ì£¼ì–´ì§€ê³  ë™ì„œë‚¨ë¶ìœ¼ë¡œ ì´ë™ì´ ê°€ëŠ¥í•˜ë‹ˆ

ì¼ë°˜ì ì¸ bfs íƒìƒ‰ìœ¼ë¡œ í’€ì´ê°€ ê°€ëŠ¥í•´ë³´ì…ë‹ˆë‹¤.

í•˜ì§€ë§Œ, ì´ ë¬¸ì œì—ì„œ í•µì‹¬ì¸ ê°€ì¤‘ì¹˜ê°€ ì´ë™ê±°ë¦¬ë¼ë©´ ì¼ë°˜ì ì¸ bfs íƒìƒ‰ìœ¼ë¡œ í’€ì´ê°€ ê°€ëŠ¥í–ˆê² ì§€ë§Œ

ì—¬ê¸°ì„œ ê°€ì¤‘ì¹˜ëŠ” ì´ë™ê±°ë¦¬ê°€ ì•„ë‹Œ ë²½ì„ ë¶€ìˆ˜ëŠ” ê°¯ìˆ˜ì…ë‹ˆë‹¤.

ë²½ì´ ìˆëƒ ì—†ëƒì— ë”°ë¼ ë¶€ìˆ˜ê³  ì´ë™í•  ìˆ˜ë„ ìˆê³  (1) ê·¸ëƒ¥ ì´ë™í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. (0)

ê°€ì¤‘ì¹˜ê°€ 1ì´ ì•„ë‹Œ 1 ë˜ëŠ” 0ì¸ ê·¸ë˜í”„ë¥¼ íƒìƒ‰í•´ì•¼ í•˜ë¯€ë¡œ

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•´ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ë³´í†µì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•  ë•Œ ì²˜ëŸ¼ ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ìœ„í•œ í…Œì´ë¸”ì„ ë§Œë“­ë‹ˆë‹¤. 

ê·¸ë¦¬ê³  ëŒ€ì‹ , ê±°ë¦¬ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ë³´ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ë²½ì„ ë¶€ìˆ˜ëŠ” ê²ƒì„ ì¤‘ì‹¬ìœ¼ë¡œ

í˜„ì¬ ìœ„ì¹˜ì—ì„œ ê° ë‹¤ìŒ ìœ„ì¹˜(ë™ì„œë‚¨ë¶)ë¡œ ì´ë™í•  ë•Œë§ˆë‹¤ ë” ìµœì†Œí•œìœ¼ë¡œ ë²½ì„ ë¶€ìˆ˜ê³  ì´ë™í•  ìˆ˜ ìˆë‹¤ë©´ ê°±ì‹ í•´ì£¼ë©´ ë©ë‹ˆë‹¤.

    if(distance[x][y] > distance[currentNode.x][currentNode.y]+maze[x][y] ){
                        distance[x][y] = distance[currentNode.x][currentNode.y]+maze[x][y];
                        priorityQueue.add(new Node(x,y,distance[x][y]));
    }
                    
# ğŸ’» ì½”ë“œ

```java

package problem.shortest.Q1261;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.PriorityQueue;

public class Main_1261 {

    static int moveX[] = {0,0,-1,1};
    static int moveY[] = {-1,1,0,0};
    static int maze[][];
    static int distance[][];
    static int n,m;

    static class Node implements Comparable<Node>{
        int x;
        int y;
        int distance;

        public Node(int x, int y, int distance) {
            this.x = x;
            this.y = y;
            this.distance = distance;
        }

        @Override
        public int compareTo(Node target) {
            // ì‘ì€ ê±°ë¦¬ ë¹„ìš©ì´ ë¨¼ì € ì˜¤ë„ë¡
            return this.distance - target.distance;
        }
    }

    public static void main(String[] args) throws IOException {
        input();
        solve();
        System.out.println(distance[n-1][m-1]);
    }

    private static void input() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String temp[] = br.readLine().split( " ");
        m= Integer.parseInt(temp[0]);
        n= Integer.parseInt(temp[1]);
        maze = new int[n][m];
        distance = new int[n][m];
        for(int i=0; i<n; i++){
            Arrays.fill(distance[i],Integer.MAX_VALUE);
        }

        for(int i=0; i<n; i++){
            temp = br.readLine().split("");
            for(int j=0; j<m; j++){
                maze[i][j] = Integer.parseInt(temp[j]);
            }
        }
        br.close();
    }
    private static void solve(){
        PriorityQueue<Node> priorityQueue = new PriorityQueue<>();
        priorityQueue.add(new Node(0,0,0));
        distance[0][0] = 0;

        while (! priorityQueue.isEmpty()){
            Node currentNode = priorityQueue.poll();
            if(currentNode.x == n-1 && currentNode.y == m-1){
                return;
            }

            for(int i=0; i<4; i++){
                int x = currentNode.x +moveX[i];
                int y = currentNode.y + moveY[i];
                if(x < 0 || y <0 || x >= n || y >= m){
                    continue;
                }
                if(distance[x][y] > distance[currentNode.x][currentNode.y]+maze[x][y] ){
                    distance[x][y] = distance[currentNode.x][currentNode.y]+maze[x][y];
                    priorityQueue.add(new Node(x,y,distance[x][y]));
                }
            }
        }
    }
}

```