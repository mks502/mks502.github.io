---
layout: post
title: ğŸ“– [ë°±ì¤€ì•Œê³ ë¦¬ì¦˜ í’€ì´] Q.1753 ìµœë‹¨ ê²½ë¡œ 
category : Algorithm
tags: [Algorithm,boj,brute force]
---
# ğŸ“– ë¬¸ì œ
https://www.acmicpc.net/problem/1753

   ë°©í–¥ê·¸ë˜í”„ê°€ ì£¼ì–´ì§€ë©´ ì£¼ì–´ì§„ ì‹œì‘ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.
   
   ë‹¨, ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ëŠ” 10 ì´í•˜ì˜ ìì—°ìˆ˜ì´ë‹¤.

# ğŸ” ì ‘ê·¼ë²•

BOJ Q.1753 ìµœë‹¨ê±°ë¦¬ ë¬¸ì œì…ë‹ˆë‹¤.

í•˜ë‚˜ì˜ ì‹œì‘ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤

ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ ëŒ€í‘œì ì¸ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í˜„ì¬ ê²½ë¡œ ì¤‘ì—ì„œ ê°€ì¥ ì§§ì€ ë¹„ìš©ì˜ ì •ì ìœ¼ë¡œ í•˜ë‚˜ ì”© ë°©ë¬¸í•´ê°€ë©°

ìƒˆë¡œìš´ ì •ì ì„ í†µí•´ ê²½ë¡œê°€ ë” ì§§ì•„ì§„ë‹¤ë©´ ìµœì†Œ ê²½ë¡œë¡œ ê°±ì‹ í•´ì¤ë‹ˆë‹¤.


                //ëª©ì ì§€ ì§í–‰ , í˜„ì¬ê¹Œì§€ ê±°ë¦¬ + í˜„ì¬ì—ì„œ ëª©ì ì§€ ê±°ë¦¬
                if(distance[destination.index] > distance[current.index] + destination.distance) {
                    // ìµœì†Œ ê±°ë¦¬ ë¹„ìš© ê°±ì‹ 
                    distance[destination.index] = distance[current.index] + destination.distance;
                    priorityQueue.add(new Node(destination.index, distance[destination.index]));
                }
                
ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ ê²½ë¡œ ì¤‘ ê°€ì¥ ì§§ì€ ë¹„ìš©ì˜ ì •ì ì„ ë°”ë¡œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì²˜ìŒì—ëŠ” ì¸ì ‘í–‰ë ¬ë¡œ í’€ì—ˆëŠ”ë° ì •ì ì˜ ê°œìˆ˜ê°€ ìµœëŒ€ 2ë§Œê°œ ê¹Œì§€ì—¬ì„œ

ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ë‚¬ì—ˆê³  ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ í†µí•´ í•´ê²°í•˜ì˜€ìŠµë‹ˆë‹¤.
                
# ğŸ’» ì½”ë“œ

```
package problem.shortestpath.Q1753;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;

public class Main_1753 {
    static final int INF = Integer.MAX_VALUE;
    static int V, E, start;
    static List<List<Node>> adList;
    static int[] distance;
    static boolean[] visited;
    static PriorityQueue<Node> priorityQueue;


    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));

        String input[] = br.readLine().split(" ");
        V = Integer.parseInt(input[0]);
        E = Integer.parseInt(input[1]);
        start = Integer.parseInt(br.readLine());

        adList = new ArrayList<>();
        // ì¸ë±ìŠ¤ë¥¼ 1ë¶€í„° í•˜ê¸° ìœ„í•´ì„œ í•œ ê°œë¥¼ ë„£ì–´ë‘ 
        adList.add(new<Node> ArrayList());
        for(int i = 1; i<= V; i++) {
            adList.add(new<Node> ArrayList());
        }

        distance = new int[V +1];
        Arrays.fill(distance, INF);

        for(int i=0; i<E; i++) {
            String[] temp = br.readLine().split(" ");
            int u = Integer.parseInt(temp[0]);
            int v = Integer.parseInt(temp[1]);
            int cost = Integer.parseInt(temp[2]);
            adList.get(u).add(new Node(v, cost));
        }

        solve(start);

        for (int i = 1; i <= V; i++) {
            if(distance[i] == INF){
                System.out.println("INF");
            }
            else {
                System.out.println(distance[i]);
            }
        }
    }

    private static void solve(int start) {
        priorityQueue = new PriorityQueue<>();
        visited = new boolean[V +1];

        distance[start] = 0;
        priorityQueue.add(new Node(start, 0));

        while(!priorityQueue.isEmpty()) {
            Node current =  priorityQueue.poll();

            if(visited[current.index]){
                continue;
            }
            visited[current.index] = true;
            // ì—°ê²°ëœ ì •ì ë“¤ì„ í™•ì¸
            for(Node destination : adList.get(current.index)) {
                //ëª©ì ì§€ ì§í–‰ , í˜„ì¬ê¹Œì§€ ê±°ë¦¬ + í˜„ì¬ì—ì„œ ëª©ì ì§€ ê±°ë¦¬
                if(distance[destination.index] > distance[current.index] + destination.distance) {
                    // ìµœì†Œ ê±°ë¦¬ ë¹„ìš© ê°±ì‹ 
                    distance[destination.index] = distance[current.index] + destination.distance;
                    priorityQueue.add(new Node(destination.index, distance[destination.index]));
                }
            }
        }
    }

}

class Node implements Comparable<Node>{
    int index;
    int distance;

    public Node(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    @Override
    public int compareTo(Node target) {
        // ì‘ì€ ê±°ë¦¬ ë¹„ìš©ì´ ë¨¼ì € ì˜¤ë„ë¡
        return this.distance - target.distance;
    }
}

```