---
layout: post
title: ğŸ“– [ë°±ì¤€ì•Œê³ ë¦¬ì¦˜ í’€ì´] Q.9370 ë¯¸í™•ì¸ ë„ì°©ì§€ ë¬¸ì œ í’€ì´ - java
category : Algorithm
tags: [Algorithm,boj,shortest path, dijkstra]
---
# ğŸ“– ë¬¸ì œ
<https://www.acmicpc.net/problem/9370>

(ì·¨ìµ)B100 ìš”ì›, ìš”ë€í•œ ì˜·ì°¨ë¦¼ì„ í•œ ì„œì»¤ìŠ¤ ì˜ˆìˆ ê°€ í•œ ìŒì´ í•œ ë„ì‹œì˜ ê±°ë¦¬ë“¤ì„ ì´ë™í•˜ê³  ìˆë‹¤. ë„ˆì˜ ì„ë¬´ëŠ” ê·¸ë“¤ì´ ì–´ë””ë¡œ ê°€ê³  ìˆëŠ”ì§€ ì•Œì•„ë‚´ëŠ” ê²ƒì´ë‹¤.

ìš°ë¦¬ê°€ ì•Œì•„ë‚¸ ê²ƒì€ ê·¸ë“¤ì´ sì§€ì ì—ì„œ ì¶œë°œí–ˆë‹¤ëŠ” ê²ƒ, ê·¸ë¦¬ê³  ëª©ì ì§€ í›„ë³´ë“¤ ì¤‘ í•˜ë‚˜ê°€ ê·¸ë“¤ì˜ ëª©ì ì§€ë¼ëŠ” ê²ƒì´ë‹¤. ê·¸ë“¤ì´ ê¸‰í•œ ìƒí™©ì´ê¸° ë•Œë¬¸ì— ëª©ì ì§€ê¹Œì§€ ìš°íšŒí•˜ì§€ ì•Šê³  ìµœë‹¨ê±°ë¦¬ë¡œ ê°ˆ ê²ƒì´ë¼ í™•ì‹ í•œë‹¤. ì´ìƒì´ë‹¤. (ì·¨ìµ)

ì–´íœ´! (ìš”ë€í•œ ì˜·ì°¨ë¦¼ì„ í–ˆì„ì§€ë„ ëª¨ë¥¼) ë“€ì˜¤ê°€ ì–´ë””ì—ë„ ë³´ì´ì§€ ì•ŠëŠ”ë‹¤. ë‹¤í–‰íˆë„ ë‹¹ì‹ ì€ í›„ê°ì´ ê°œë§Œí¼ ë›°ì–´ë‚˜ë‹¤. ì´ í›„ê°ìœ¼ë¡œ ê·¸ë“¤ì´ gì™€ h êµì°¨ë¡œ ì‚¬ì´ì— ìˆëŠ” ë„ë¡œë¥¼ ì§€ë‚˜ê°”ë‹¤ëŠ” ê²ƒì„ ì•Œì•„ëƒˆë‹¤.

ì´ ë“€ì˜¤ëŠ” ëŒ€ì²´ ì–´ë””ë¡œ ê°€ê³  ìˆëŠ” ê²ƒì¼ê¹Œ?

![example](/images/2021-4-22/example.png)

ì˜ˆì œ ì…ë ¥ì˜ ë‘ ë²ˆì§¸ ì¼€ì´ìŠ¤ë¥¼ ì‹œê°í™”í•œ ê²ƒì´ë‹¤. ì´ ë“€ì˜¤ëŠ” íšŒìƒ‰ ì›ì—ì„œ ë‘ ê²€ì€ ì› ì¤‘ í•˜ë‚˜ë¡œ ê°€ê³  ìˆê³  ì ì„ ìœ¼ë¡œ í‘œì‹œëœ ë„ë¡œì—ì„œ ëƒ„ìƒˆë¥¼ ë§¡ì•˜ë‹¤. ë”°ë¼ì„œ ê·¸ë“¤ì€ 6ìœ¼ë¡œ í–¥í•˜ê³  ìˆë‹¤.

# ğŸ” ì ‘ê·¼ë²•

BOJ Q.9370 ë¯¸í™•ì¸ ë„ì°©ì§€ ë¬¸ì œì…ë‹ˆë‹¤.

ìš”ë€í•œ ì˜·ì°¨ë¦¼ì„ í•œ ì„œì»¤ìŠ¤ ì˜ˆìˆ ê°€ í•œ ìŒì´ í•œ ë„ì‹œì˜ ê±°ë¦¬ë“¤ì„ ì´ë™í•˜ê³  ìˆì„ ë•Œ ê·¸ ë“€ì˜¤ê°€ ì–´ë””ë¡œ ê°€ê³  ìˆëŠ” ê²ƒì¸ì§€ ëª©ì ì§€ë¥¼ ì°¾ì•„ì•¼ í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

ì¶œë°œ ì§€ì ìœ¼ë¡œ sê°€ ì£¼ì–´ì§€ê³  ëª©ì ì§€ í›„ë³´ë“¤ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.

s -> ëª©ì ì§€ í›„ë³´ë“¤ ì„ ì‚´í´ë³´ë©´ ë˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

í•œ ì§€ì ì—ì„œ ëª©ì ì§€ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•´ì•¼í•˜ë‹ˆ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•´ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤. 

ë‹¨, ì¡°ê±´ì´ ìˆìŠµë‹ˆë‹¤. ë¬¸ì œì— ì£¼ì–´ì§„ ê²ƒ ì²˜ëŸ¼ gì™€ h ì‚¬ì´ì˜ ë„ë¡œë¥¼ ë°˜ë“œì‹œ ì§€ë‚˜ê°€ì•¼ í•©ë‹ˆë‹¤. 

gì™€ hë¥¼ ë°˜ë“œì‹œ ì§€ë‚˜ê°€ëŠ” ê²½ë¡œë“¤ì„ ë§Œë“¤ì–´ì£¼ë©´ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ì¦‰, 

1.  s -> g -> h -> ëª©ì ì§€ 
2.  s -> h -> g -> ëª©ì ì§€

ì´ ë‘ ê²½ë¡œ ì¤‘ ìµœë‹¨ ê±°ë¦¬ì¸ ê²ƒì„ êµ¬í•˜ë©´ ë©ë‹ˆë‹¤.

        int min = Math.min(dijkstra(s, g) + dijkstra(g, h) + dijkstra(h, destination), dijkstra(s, h) + dijkstra(h, g) + dijkstra(g, destination));
        
ë˜í•œ! ëª©ì ì§€ í›„ë³´ë“¤ ì¤‘ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°ë“¤ì€ ì œì™¸í•´ì•¼í•©ë‹ˆë‹¤.

ë¬¸ì œë¥¼ ì˜ ì‚´í´ë´ì•¼í–ˆìŠµë‹ˆë‹¤. 

    ë“¤ì´ ê¸‰í•œ ìƒí™©ì´ê¸° ë•Œë¬¸ì— ëª©ì ì§€ê¹Œì§€ ìš°íšŒí•˜ì§€ ì•Šê³  ìµœë‹¨ê±°ë¦¬ë¡œ ê°ˆ ê²ƒì´ë¼ í™•ì‹ í•œë‹¤. ì´ìƒì´ë‹¤. (ì·¨ìµ)
    
ìœ„ì˜ ë‚´ìš©ê³¼ ê°™ì´ ì´ ë“€ì˜¤ëŠ” ì ˆëŒ€ ëª©ì ì§€ê¹Œì§€ ìš°íšŒí•˜ì§€ ì•Šê³  ìµœë‹¨ê±°ë¦¬ë¡œ ì›€ì§ì¸ë‹¤ëŠ” ê²ƒ ì…ë‹ˆë‹¤.

ëª©ì ì§€ í›„ë³´ë“¤ ì¤‘ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°ëŠ” ìš°íšŒí•˜ëŠ” ê²½ìš°ì…ë‹ˆë‹¤.

ê·¸ëŸ¬ë¯€ë¡œ ìµœì¢…ì ìœ¼ë¡œ g,h ì‚¬ì´ì˜ ë„ë¡œë¥¼ ë°˜ë“œì‹œ ì§€ë‚˜ê°€ëŠ” ê²½ë¡œì´ë©´ì„œ

s->ëª©ì ì§€ê¹Œì§€ì˜ ìµœë‹¨ê²½ë¡œì¸ì§€ë¥¼ í™•ì¸í•˜ë©´ ë‹µì„ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```
int min = Math.min(dijkstra(s, g) + dijkstra(g, h) + dijkstra(h, destination), dijkstra(s, h) + dijkstra(h, g) + dijkstra(g, destination));
int shortestPath = dijkstra(s, destination);
if (shortestPath == min) {
    answerQueue.add(destination); 
}
```

# ğŸ’» ì½”ë“œ

```java

package problem.shortest.Q9370;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;

public class Main_9370 {

    static class Node implements Comparable<Node> {
        int index;
        int distance;

        public Node(int index, int distance) {
            this.index = index;
            this.distance = distance;
        }

        @Override
        public int compareTo(Node target) {
            // ì‘ì€ ê±°ë¦¬ ë¹„ìš©ì´ ë¨¼ì € ì˜¤ë„ë¡
            return this.distance - target.distance;
        }
    }

    static final int INF = 100000000;
    static int start, end;
    static int T, n, m, t;
    static int s, g, h;
    static List<List<Node>> adList;
    static int[] distance;
    static boolean[] visited;
    static PriorityQueue<Node> priorityQueue;
    static StringBuilder sb = new StringBuilder();


    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        T = Integer.parseInt(br.readLine());

        for (int tc = 0; tc < T; tc++) {


            String input[] = br.readLine().split(" ");
            n = Integer.parseInt(input[0]);
            m = Integer.parseInt(input[1]);
            t = Integer.parseInt(input[2]);

            input = br.readLine().split(" ");
            s = Integer.parseInt(input[0]);
            g = Integer.parseInt(input[1]);
            h = Integer.parseInt(input[2]);

            adList = new ArrayList<>();
            // ì¸ë±ìŠ¤ë¥¼ 1ë¶€í„° í•˜ê¸° ìœ„í•´ì„œ í•œ ê°œë¥¼ ë„£ì–´ë‘ 
            adList.add(new <Node>ArrayList());
            for (int i = 1; i <= n; i++) {
                adList.add(new <Node>ArrayList());
            }

            for (int i = 0; i < m; i++) {
                String[] temp = br.readLine().split(" ");
                int u = Integer.parseInt(temp[0]);
                int v = Integer.parseInt(temp[1]);
                int cost = Integer.parseInt(temp[2]);
                adList.get(u).add(new Node(v, cost));
                adList.get(v).add(new Node(u, cost));
            }


            PriorityQueue<Integer> answerQueue = new PriorityQueue<>();
            for (int i = 0; i < t; i++) {
                int destination = Integer.parseInt(br.readLine());

                int min = Math.min(dijkstra(s, g) + dijkstra(g, h) + dijkstra(h, destination), dijkstra(s, h) + dijkstra(h, g) + dijkstra(g, destination));
                int shortestPath = dijkstra(s, destination);
                if (shortestPath == min) {
                    answerQueue.add(destination);
                }
            }
            
            while (!answerQueue.isEmpty()) {
                sb.append(answerQueue.poll() + " ");
            }
            sb.append("\n");
        }
        System.out.println(sb.toString());
    }

    private static int dijkstra(int start, int end) {
        priorityQueue = new PriorityQueue<>();
        visited = new boolean[n + 1];
        distance = new int[n + 1];
        Arrays.fill(distance, INF);

        distance[start] = 0;
        priorityQueue.add(new Node(start, 0));

        while (!priorityQueue.isEmpty()) {
            Node current = priorityQueue.poll();

            if (visited[current.index]) {
                continue;
            }
            visited[current.index] = true;
            // ì—°ê²°ëœ ì •ì ë“¤ì„ í™•ì¸
            for (Node destination : adList.get(current.index)) {
                //ëª©ì ì§€ ì§í–‰ , í˜„ì¬ê¹Œì§€ ê±°ë¦¬ + í˜„ì¬ì—ì„œ ëª©ì ì§€ ê±°ë¦¬
                if (distance[destination.index] > distance[current.index] + destination.distance) {
                    // ìµœì†Œ ê±°ë¦¬ ë¹„ìš© ê°±ì‹ 
                    distance[destination.index] = distance[current.index] + destination.distance;
                    priorityQueue.add(new Node(destination.index, distance[destination.index]));
                }
            }
        }
        return distance[end];
    }
}


```