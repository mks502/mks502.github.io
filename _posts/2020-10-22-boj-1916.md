---
layout: post
title: ğŸ“– [ë°±ì¤€ì•Œê³ ë¦¬ì¦˜ í’€ì´] Q.1916 ìµœì†Œë¹„ìš© êµ¬í•˜ê¸°
category : Algorithm
tags: [Algorithm,boj,shortestPath]
---
# ğŸ“– ë¬¸ì œ
https://www.acmicpc.net/problem/1916

Nê°œì˜ ë„ì‹œê°€ ìˆë‹¤. ê·¸ë¦¬ê³  í•œ ë„ì‹œì—ì„œ ì¶œë°œí•˜ì—¬ ë‹¤ë¥¸ ë„ì‹œì— ë„ì°©í•˜ëŠ” Mê°œì˜ ë²„ìŠ¤ê°€ ìˆë‹¤.

ìš°ë¦¬ëŠ” Aë²ˆì§¸ ë„ì‹œì—ì„œ Bë²ˆì§¸ ë„ì‹œê¹Œì§€ ê°€ëŠ”ë° ë“œëŠ” ë²„ìŠ¤ ë¹„ìš©ì„ ìµœì†Œí™” ì‹œí‚¤ë ¤ê³  í•œë‹¤.

Aë²ˆì§¸ ë„ì‹œì—ì„œ Bë²ˆì§¸ ë„ì‹œê¹Œì§€ ê°€ëŠ”ë° ë“œëŠ” ìµœì†Œë¹„ìš©ì„ ì¶œë ¥í•˜ì—¬ë¼. ë„ì‹œì˜ ë²ˆí˜¸ëŠ” 1ë¶€í„° Nê¹Œì§€ì´ë‹¤.

# ğŸ” ì ‘ê·¼ë²•

BOJ Q.1916 ìµœë‹¨ê±°ë¦¬ ë¬¸ì œì…ë‹ˆë‹¤.

í•˜ë‚˜ì˜ ì‹œì‘ì ì—ì„œ ëª©í‘œ ì§€ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì…ë‹ˆë‹¤.

ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ ëŒ€í‘œì ì¸ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í’€ì´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í˜„ì¬ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œ ì¤‘ì—ì„œ ê°€ì¥ ì§§ì€ ë¹„ìš©ì˜ ì •ì ìœ¼ë¡œ í•˜ë‚˜ ì”© ë°©ë¬¸í•´ê°€ë©°

ìƒˆë¡œìš´ ì •ì ì„ í†µí•´ ê²½ë¡œê°€ ë” ì§§ì•„ì§„ë‹¤ë©´ ìµœì†Œ ê²½ë¡œë¡œ ê°±ì‹ í•´ì¤ë‹ˆë‹¤.

ì‹œì‘ì§€ë¡œë¶€í„°ì˜ ëª¨ë“  ì •ì ì— ëŒ€í•œ ìµœì†Œê²½ë¡œë¥¼ êµ¬í•˜ì—¬

ì‹œì‘ì§€ë¡œë¶€í„° ë„ì°©ì§€ê¹Œì§€ì˜ ìµœì†Œ ê²½ë¡œë¥¼ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


                //ëª©ì ì§€ ì§í–‰ , í˜„ì¬ê¹Œì§€ ê±°ë¦¬ + í˜„ì¬ì—ì„œ ëª©ì ì§€ ê±°ë¦¬
                if(distance[destination.index] > distance[current.index] + destination.distance) {
                    // ìµœì†Œ ê±°ë¦¬ ë¹„ìš© ê°±ì‹ 
                    distance[destination.index] = distance[current.index] + destination.distance;
                    priorityQueue.add(new Node(destination.index, distance[destination.index]));
                }
                
                
# ğŸ’» ì½”ë“œ

```
package problem.shortest.Q1916;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;

public class Main_1916 {
    static final int INF = 987654321;
    static int V, E, start,end;
    static List<List<Node>> adList;
    static int[] distance;
    static boolean[] visited;
    static PriorityQueue<Node> priorityQueue;


    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        V = Integer.parseInt(br.readLine());
        E = Integer.parseInt(br.readLine());

        adList = new ArrayList<>();
        // ì¸ë±ìŠ¤ë¥¼ 1ë¶€í„° í•˜ê¸° ìœ„í•´ì„œ í•œ ê°œë¥¼ ë„£ì–´ë‘ 
        adList.add(new <Node>ArrayList());
        for (int i = 1; i <= V; i++) {
            adList.add(new <Node>ArrayList());
        }

        for (int i = 0; i < E; i++) {
            String[] temp = br.readLine().split(" ");
            int u = Integer.parseInt(temp[0]);
            int v = Integer.parseInt(temp[1]);
            int cost = Integer.parseInt(temp[2]);
            adList.get(u).add(new Node(v, cost));
        }
        String temp[] = br.readLine().split(" ");
        start = Integer.parseInt(temp[0]);
        end = Integer.parseInt(temp[1]);

        solve(start);


        if (distance[end] == INF) {
            System.out.println("INF");
        } else {
            System.out.println(distance[end]);
        }

    }

    private static void solve(int start) {
        priorityQueue = new PriorityQueue<>();
        visited = new boolean[V +1];

        distance = new int[V + 1];
        Arrays.fill(distance, INF);

        distance[start] = 0;
        priorityQueue.add(new Node(start, 0));

        while(!priorityQueue.isEmpty()) {
            Node current =  priorityQueue.poll();

            if(visited[current.index]){
                continue;
            }
            visited[current.index] = true;
            // ì—°ê²°ëœ ì •ì ë“¤ì„ í™•ì¸
            for(Node destination : adList.get(current.index)) {
                //ëª©ì ì§€ ì§í–‰ , í˜„ì¬ê¹Œì§€ ê±°ë¦¬ + í˜„ì¬ì—ì„œ ëª©ì ì§€ ê±°ë¦¬
                if(distance[destination.index] > distance[current.index] + destination.distance) {
                    // ìµœì†Œ ê±°ë¦¬ ë¹„ìš© ê°±ì‹ 
                    distance[destination.index] = distance[current.index] + destination.distance;
                    priorityQueue.add(new Node(destination.index, distance[destination.index]));
                }
            }
        }
    }
}

class Node implements Comparable<Node>{
    int index;
    int distance;

    public Node(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    @Override
    public int compareTo(Node target) {
        // ì‘ì€ ê±°ë¦¬ ë¹„ìš©ì´ ë¨¼ì € ì˜¤ë„ë¡
        return this.distance - target.distance;
    }
}

```